{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/javascript": [
       "if (!(\"Notification\" in window)) {\n",
       "    alert(\"This browser does not support desktop notifications, so the %%notify magic will not work.\");\n",
       "} else if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {\n",
       "    Notification.requestPermission(function (permission) {\n",
       "        if(!('permission' in Notification)) {\n",
       "            Notification.permission = permission;\n",
       "        }\n",
       "    })\n",
       "}\n"
      ],
      "text/plain": [
       "<IPython.core.display.Javascript object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%load_ext jupyternotify\n",
    "import pennylane as qml\n",
    "from pennylane import numpy as np\n",
    "import tensorflow as tf\n",
    "from sympy.physics.quantum.dagger import Dagger\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "px = np.array([[0 + 0j, 1 + 0j] , [1 + 0j, 0+0j]])\n",
    "py = np.array( [[0 + 0j, 0 - 1j] , [0 + 1j, 0+0j]])\n",
    "pz = np.array( [[1 + 0j, 0 + 0j] , [0 + 0j, -1+0j]])\n",
    "iden = np.array( [[1 + 0j, 0 + 0j] , [0 + 0j, 1+0j]])\n",
    "\n",
    "n = 1\n",
    "lamb = np.float(2)\n",
    "s = np.exp(-1 / (2 * lamb)) - 1\n",
    "cst1 = (s / 2 + 1) ** 2\n",
    "cst2 = (s / 2) * (s / 2 + 1)\n",
    "cst3 = (s / 2) ** 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fidelity(rsv, gsv):\n",
    "    \n",
    "    rsv_conj = np.conj(rsv)\n",
    "    fid = sum(rsv_conj*gsv) * np.conj(sum(rsv_conj*gsv))\n",
    "    \n",
    "    return fid\n",
    "\n",
    "dev1 = qml.device('default.qubit', wires=1) #real\n",
    "dev2 = qml.device('default.qubit', wires=1) #generator\n",
    "\n",
    "obs_list = [qml.Identity(0), qml.PauliX(0) , qml.PauliY(0), qml.PauliZ(0)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def real_circuit(real_weights, wires, **kwargs):\n",
    "    \n",
    "    qml.RX(real_weights[0], wires=0)\n",
    "    qml.RY(real_weights[1], wires=0)\n",
    "    qml.RZ(real_weights[2], wires=0)\n",
    "\n",
    "qnodes_real = qml.map(real_circuit, obs_list, dev1, measure=\"expval\",  interface=\"tf\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def gen_circuit(gen_weights, wires, **kwargs):\n",
    "    \n",
    "    qml.RX(gen_weights[0], wires=0)\n",
    "    qml.RY(gen_weights[1], wires=0)\n",
    "    qml.RZ(gen_weights[2], wires=0)\n",
    "\n",
    "qnodes_gen = qml.map(gen_circuit, obs_list, dev2, measure=\"expval\",  interface=\"tf\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "def discriminator(real_exp, gen_exp, disc_weights):\n",
    "    \n",
    "    phi_matrix = disc_weights[0]*iden + disc_weights[1]*px + disc_weights[2]*py + disc_weights[3]*pz \n",
    "    psi_matrix = disc_weights[4]*iden + disc_weights[5]*px + disc_weights[6]*py + disc_weights[7]*pz \n",
    "    \n",
    "    phi_exp = disc_weights[0]*gen_exp[0] + disc_weights[1]*gen_exp[1] + disc_weights[2]*gen_exp[2] + disc_weights[3]*gen_exp[3]\n",
    "    psi_exp = disc_weights[4]*real_exp[0] + disc_weights[5]*real_exp[1] + disc_weights[6]*real_exp[2] + disc_weights[7]*real_exp[3]\n",
    "\n",
    "    A = tf.linalg.expm( (-1/lamb) * phi_matrix )\n",
    "    B = tf.linalg.expm( (1/lamb) * psi_matrix )\n",
    "    \n",
    "    term1 = np.matmul( Dagger(gen_sv) , np.matmul(A.numpy(), gen_sv) )\n",
    "    term2 = np.matmul( Dagger(real_sv) , np.matmul(B.numpy(), real_sv) )\n",
    "    term3 = np.matmul( Dagger(gen_sv) , np.matmul(B.numpy(), real_sv) )\n",
    "    term4 = np.matmul( Dagger(real_sv) , np.matmul(A.numpy(), gen_sv) )\n",
    "    term5 = np.matmul( Dagger(gen_sv) , np.matmul(A.numpy(), real_sv) )\n",
    "    term6 = np.matmul( Dagger(real_sv) , np.matmul(B.numpy(), gen_sv) )\n",
    "    term7 = np.matmul( Dagger(gen_sv) , np.matmul(B.numpy(), gen_sv) )\n",
    "    term8 = np.matmul( Dagger(real_sv) , np.matmul(A.numpy(), real_sv) )\n",
    "\n",
    "    regterm = (lamb / np.e * (cst1 * term1 * term2 - cst2 * term3 * term4 - cst2 * term5 * term6 + cst3 * term7 * term8)).item()\n",
    "\n",
    "    return psi_exp , phi_exp , regterm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "def disc_loss(disc_weights):\n",
    "    \n",
    "    psi_exp , phi_exp , regterm = discriminator(real_exp, gen_exp, disc_weights)\n",
    "    loss = np.real(psi_exp - phi_exp - regterm)\n",
    "    \n",
    "    return -loss \n",
    "\n",
    "\n",
    "def gen_loss(gen_weights):\n",
    "     \n",
    "    gen_exp = qnodes_gen(gen_weights)\n",
    "    gen_sv = dev2.state\n",
    "\n",
    "    psi_exp , phi_exp , regterm = discriminator(real_exp, gen_exp, disc_weights)\n",
    "    loss = np.real(psi_exp - phi_exp - regterm)\n",
    "    \n",
    "    return loss \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(<tf.Tensor: shape=(), dtype=float64, numpy=1.9918831566410213>,\n",
       " <tf.Tensor: shape=(), dtype=float64, numpy=1.8511014742970033>,\n",
       " (1.2874031841494227-2.517106890503796e-16j))"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "real_weights = np.random.uniform(0,2,3)\n",
    "real_exp = qnodes_real(real_weights)\n",
    "real_sv = dev1.state\n",
    "\n",
    "gen_weights = np.random.uniform(0,2,3)\n",
    "gen_exp = qnodes_gen(gen_weights)\n",
    "gen_sv = dev2.state\n",
    "\n",
    "disc_weights = np.random.uniform(1,1,8)\n",
    "\n",
    "discriminator(real_exp, gen_exp, disc_weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "discriminator_optimizer = tf.keras.optimizers.Adam(0.1)\n",
    "generator_optimizer = tf.keras.optimizers.Adam(0.1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "Passed in object of type <class 'pennylane.numpy.tensor.tensor'>, not tf.Tensor",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-10-bef8d58710db>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m     \u001b[0mcostd\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mlambda\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mdisc_loss\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdisc_weights\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 14\u001b[0;31m     \u001b[0mdiscriminator_optimizer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mminimize\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcostd\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdisc_weights\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     15\u001b[0m     \u001b[0mdloss\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdisc_loss\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdisc_weights\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/tensorflow/python/keras/optimizer_v2/optimizer_v2.py\u001b[0m in \u001b[0;36mminimize\u001b[0;34m(self, loss, var_list, grad_loss, name)\u001b[0m\n\u001b[1;32m    332\u001b[0m     \"\"\"\n\u001b[1;32m    333\u001b[0m     grads_and_vars = self._compute_gradients(\n\u001b[0;32m--> 334\u001b[0;31m         loss, var_list=var_list, grad_loss=grad_loss)\n\u001b[0m\u001b[1;32m    335\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    336\u001b[0m     \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mapply_gradients\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mgrads_and_vars\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/tensorflow/python/keras/optimizer_v2/optimizer_v2.py\u001b[0m in \u001b[0;36m_compute_gradients\u001b[0;34m(self, loss, var_list, grad_loss)\u001b[0m\n\u001b[1;32m    385\u001b[0m     \u001b[0;32mwith\u001b[0m \u001b[0mbackprop\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mGradientTape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mtape\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    386\u001b[0m       \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mcallable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvar_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 387\u001b[0;31m         \u001b[0mtape\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvar_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    388\u001b[0m       \u001b[0mloss_value\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mloss\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    389\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mcallable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvar_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/tensorflow/python/eager/backprop.py\u001b[0m in \u001b[0;36mwatch\u001b[0;34m(self, tensor)\u001b[0m\n\u001b[1;32m    879\u001b[0m       \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0m_pywrap_utils\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIsTensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mt\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0m_pywrap_utils\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIsVariable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mt\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    880\u001b[0m         raise ValueError(\"Passed in object of type {}, not tf.Tensor\".format(\n\u001b[0;32m--> 881\u001b[0;31m             type(t)))\n\u001b[0m\u001b[1;32m    882\u001b[0m       \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mbackprop_util\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIsTrainable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mt\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    883\u001b[0m         logging.log_first_n(\n",
      "\u001b[0;31mValueError\u001b[0m: Passed in object of type <class 'pennylane.numpy.tensor.tensor'>, not tf.Tensor"
     ]
    },
    {
     "data": {
      "application/javascript": [
       "$(document).ready(\n",
       "    function() {\n",
       "        function appendUniqueDiv(){\n",
       "            // append a div with our uuid so we can check that it's already\n",
       "            // been sent and avoid duplicates on page reload\n",
       "            var notifiedDiv = document.createElement(\"div\")\n",
       "            notifiedDiv.id = \"ff327ea3-a428-4f83-aba2-a40d88a00fba\"\n",
       "            element.append(notifiedDiv)\n",
       "        }\n",
       "\n",
       "        // only send notifications if the pageload is complete; this will\n",
       "        // help stop extra notifications when a saved notebook is loaded,\n",
       "        // which during testing gives us state \"interactive\", not \"complete\"\n",
       "        if (document.readyState === 'complete') {\n",
       "            // check for the div that signifies that the notification\n",
       "            // was already sent\n",
       "            if (document.getElementById(\"ff327ea3-a428-4f83-aba2-a40d88a00fba\") === null) {\n",
       "                var notificationPayload = {\"requireInteraction\": false, \"icon\": \"/static/base/images/favicon.ico\", \"body\": \"Cell execution has finished!\"};\n",
       "                if (Notification.permission !== 'denied') {\n",
       "                    if (Notification.permission !== 'granted') { \n",
       "                        Notification.requestPermission(function (permission) {\n",
       "                            if(!('permission' in Notification)) {\n",
       "                                Notification.permission = permission\n",
       "                            }\n",
       "                        })\n",
       "                    }\n",
       "                    if (Notification.permission === 'granted') {\n",
       "                    var notification = new Notification(\"Jupyter Notebook\", notificationPayload)\n",
       "                    appendUniqueDiv()\n",
       "                    notification.onclick = function () {\n",
       "                        window.focus();\n",
       "                        this.close();\n",
       "                        };\n",
       "                    } \n",
       "                }     \n",
       "            }\n",
       "        }\n",
       "    }\n",
       ")\n"
      ],
      "text/plain": [
       "<IPython.core.display.Javascript object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 223 ms, sys: 60.8 ms, total: 284 ms\n",
      "Wall time: 282 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "%%notify\n",
    "\n",
    "fid = fidelity(real_sv, gen_sv)\n",
    "\n",
    "f = []\n",
    "f.append(fid)\n",
    "dloss=[]\n",
    "gloss=[]\n",
    "\n",
    "niter = 0 \n",
    "\n",
    "\n",
    "while fid <0.99:\n",
    "    \n",
    "    costd = lambda: disc_loss(disc_weights)\n",
    "    discriminator_optimizer.minimize(costd, disc_weights)\n",
    "    dloss.append(disc_loss(disc_weights))\n",
    "    \n",
    "    costg = lambda: gen_loss(gen_weights)\n",
    "    generator_optimizer.minimize(costg, gen_weights)\n",
    "    gloss.append(gen_loss(gen_weights))\n",
    "\n",
    "    gen_exp = qnodes_gen(gen_weights)\n",
    "    gen_sv = dev2.state\n",
    "\n",
    "\n",
    "    fid = fidelity(real_sv, gen_sv)\n",
    "    \n",
    "    f.append(fid)\n",
    "             \n",
    "    niter += 1\n",
    "\n",
    "    if niter == 1000:\n",
    "\n",
    "        break \n",
    "    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
